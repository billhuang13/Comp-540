# -*- coding: utf-8 -*-
"""DataExploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ufu_SxsdgaiPw1F4SzsQRYJspeE7Ieu5
"""

!pip install pydicom

!pip install fastcore

import pandas as pd
from glob import glob
import pydicom
import matplotlib.pyplot as plt
import os
import numpy as np
from PIL import Image
import fastcore
from tqdm import tqdm
import cv2

# masks are run-length-encoded (RLE). These functions are meant to convert between
# original masks and encoded masks
def run_length_encode(component):
    if component.sum() == 0:
        return '-1'
    component = np.hstack([np.array([0]), component.T.flatten(), np.array([0])])
    start  = np.where(component[1: ] > component[:-1])[0]
    end    = np.where(component[:-1] > component[1: ])[0]
    length = end-start

    rle = []
    for i in range(len(length)):
        if i==0:
            rle.extend([start[0],length[0]])
        else:
            rle.extend([start[i]-end[i-1],length[i]])

    rle = ' '.join([str(r) for r in rle])
    return rle

def run_length_decode(rle, height=1024, width=1024, fill_value=1):
    component = np.zeros((height,width), np.float32)
    if rle == '-1':
        return component
    component = component.reshape(-1)
    rle  = np.array([int(s) for s in rle.split(' ')])
    rle  = rle.reshape(-1, 2)

    start = 0
    for index,length in rle:
        start = start+index
        end   = start+length
        component[start : end] = fill_value
        start = end

    component = component.reshape(width, height).T
    return component

from google.colab import drive
drive.mount('/content/drive')

"""# Data preparation"""

data_path="/content/drive/Shareddrives/Comp 540/Test_shared_Drive/raw_data/train"

# First look at the csv file which contains image id and the encoded pixels
train_meta = pd.read_csv(f"{data_path}/train-rle.csv")
train_meta.columns = [o.strip() for o in train_meta.columns]

train_meta.columns

train_meta.head(3)

"""Some images may have more than 1 rle/mask, which probably means more places where Pneumotherax is found."""

# some of the images shown belows contain multiple masks
train_meta.ImageId.value_counts()[:4]

# These images in the training set are in the DICOM format
train_path = (f"{data_path}/dicom-images-train")

"""All the images are in a structure like

```
someid/someid/image_id.dcm
dicom-images-train/1.2.27**/1.2.276.0.**/1.2.276.0.7230010.3.1.4**.dcm

```
"""

train_files = list(glob(f'{train_path}/*/*/*.dcm'))

"""Total train images"""

len(train_files)

train_meta['EncodedPixels'].str.strip()

# 9378 images have no masks, 2669 do
stats_mask = (train_meta.drop_duplicates(['ImageId'])['EncodedPixels'].str.strip()!='-1').value_counts().reset_index()
stats_mask

annotated_images = stats_mask['count'].sum()
annotated_images

"""We got more images (12089) than labels (12047), now filter them out."""

train_files = [o for o in train_files if os.path.basename(o)[:-4] in train_meta.ImageId.values]

assert len(train_files) == annotated_images
len(train_files)

"""Explore dicom files."""

sample = train_files[7]
sample

dicom_obj = pydicom.dcmread(sample)

"""A Dicom object contains metadata and image data, we will be focusing primarily on Image data"""

# Images in 1024 by 1024
plt.imshow(dicom_obj.pixel_array, cmap="gray");
dicom_obj.pixel_array.shape

print(dicom_obj.pixel_array)
print(dicom_obj.pixel_array.shape)

# resize the images to 128 by 128 so they take less space in the future
first_array = dicom_obj.pixel_array
resized_array = cv2.resize(first_array, (128, 128), interpolation=cv2.INTER_AREA)
plt.imshow(resized_array, cmap='gray')

"""Dicom files also hold metadata information. Lets look at some of the attributes, but not use it for now. If required we will use it later."""

meta_data = [(o.keyword,o.value) for o in dicom_obj]

meta_data[:5]

"""# Save images and masks as png files"""

# creating now directories to store the images and masks in png format
img_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_1img_mask/images")
mask_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_1img_mask/mask")

os.makedirs(img_path, exist_ok=True)
os.makedirs(mask_path, exist_ok=True)

mask = np.zeros((1024,1024)) #Images are of size 1024*1024
for rle in rles:
    rle = rle.strip()
    if rle != "-1":
        mask += run_length_decode(rle)

mask = mask.clip(0,1).astype(np.uint8) * 255
mask = Image.fromarray(mask)
mask = mask.resize((128, 128), resample=cv2.INTER_AREA)
mask

resized_array

plt.imshow(resized_array, cmap='gray')
plt.imshow(mask,cmap='jet',alpha=0.3)
plt.show()

def save_dcm_png(file,dst_path):
    """Extracts image from DCM file and saves it as a PNG file in the given path"""
    fname = os.path.basename(file)[:-4]
    pyds = pydicom.dcmread(file)
    resized_array = cv2.resize(pyds.pixel_array, (128, 128), interpolation=cv2.INTER_AREA)
    img = Image.fromarray(resized_array)
    img.save(f'{dst_path}/{fname}.png')

def get_rle_mask(df,file):
    """Converts mask from rle format to PIL Image format"""
    target_size=(128, 128)
    fname=os.path.basename(file)[:-4]
    mask = np.zeros((1024,1024))
    rles = df[df['ImageId']==fname]['EncodedPixels']
    print(rles)
    for rle in rles:
        rle = rle.strip()
        if rle != "-1":
            mask += run_length_decode(rle)
    mask = mask.clip(0,1).astype(np.uint8) * 255
    mask = Image.fromarray(mask)
    # resizing here so that the masks match with the images
    mask = mask.resize(target_size)
    return mask

def save_rle_mask(df,file,dst_path):
    fname=os.path.basename(file)[:-4]
    mask = get_rle_mask(df,file)
    mask.save(f'{dst_path}/{fname}.png')

train_meta

train_meta[train_meta.ImageId ==os.path.basename(train_files[7])[:-4]]['EncodedPixels']

train_files[7]

# take a look at the image with the corresponding mask
ix=2
plt.imshow(resized_array, cmap='gray')
plt.imshow(get_rle_mask(train_meta,train_files[ix]),cmap='jet',alpha=0.3)
plt.show()

def setup(file):
    save_dcm_png(file,img_path)
    save_rle_mask(train_meta, file, mask_path)

from fastcore.parallel import parallel

#Lets make it faster by using all the cores.
parallel(setup, train_files, n_workers=7, progress=True)

"""# Get Image from png"""

img_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_1img_mask/images")
mask_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_1img_mask/mask")

def plt_img_mask(img,msk):
    plt.imshow(img,cmap='gray')
    plt.imshow(msk,cmap='jet',alpha=0.3)

idx = 2
img = Image.open(glob(img_path+"/*.png")[idx])
msk = Image.open(glob(mask_path+"/*.png")[idx])
plt_img_mask(img,msk)

"""A quick way to pick an index which contains a image with Pneumotherax"""

[i for i,o in enumerate(glob(mask_path+"/*.png")[:30]) if np.array(Image.open(o)).sum()>0]

glob(mask_path+"/*.png")[8]

"""# save according to label"""

img_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_1img_mask/images")
mask_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_1img_mask/mask")

def getLabelByMask(file):
    return np.array(Image.open(file)).sum()>0

masks=glob(mask_path+"/*.png")

os.path.basename(masks[0])

positive_imgs=[]
positive_masks=[]
positive_imgs_names=[]

negative_imgs=[]
negative_masks=[]
negative_imgs_names=[]

all_imgs = []
all_masks = []
all_imgs_names = []
for mask in tqdm(masks):
    fname=os.path.basename(mask)
    label=getLabelByMask(mask)
    all_imgs.append(np.array(Image.open(img_path+f"/{fname}")))
    all_imgs_names.append(fname)
    all_masks.append(np.array(Image.open(mask_path+f"/{fname}")))
    if label:
        positive_imgs.append(np.array(Image.open(img_path+f"/{fname}")))
        positive_imgs_names.append(fname)
        positive_masks.append(np.array(Image.open(mask_path+f"/{fname}")))
    else:
        negative_imgs.append(np.array(Image.open(img_path+f"/{fname}")))
        negative_imgs_names.append(fname)
        negative_masks.append(np.array(Image.open(mask_path+f"/{fname}")))

positive_imgs=np.array(positive_imgs)
negative_imgs=np.array(negative_imgs)

positive_imgs_names=np.array(positive_imgs_names)
negative_imgs_names=np.array(negative_imgs_names)

positive_masks=np.array(positive_masks)
negative_masks=np.array(negative_masks)

print(positive_imgs.shape)
print(negative_imgs.shape)

print(positive_imgs_names.shape)
print(negative_imgs_names.shape)

print(positive_masks.shape)
print(negative_masks.shape)

# creating a new directory to store all the images, masks, and their names
new_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_2img_mask_npy")

os.makedirs(new_path, exist_ok=True)

np.save(new_path + '/positive_imgs.npy', positive_imgs, allow_pickle=True)
np.save(new_path + '/negative_imgs.npy', negative_imgs, allow_pickle=True)

np.save(new_path + '/positive_imgs_names.npy', positive_imgs_names, allow_pickle=True)
np.save(new_path + '/negative_imgs_names.npy', negative_imgs_names, allow_pickle=True)

np.save(new_path + '/positive_masks.npy', positive_masks, allow_pickle=True)
np.save(new_path + '/negative_masks.npy', negative_masks, allow_pickle=True)

"""# Save the test images"""

# creating a new directory to store the testing dataset
test_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_3test_imgs")
os.makedirs(test_path, exist_ok=True)

test_files = glob('/content/drive/Shareddrives/Comp 540/Test_shared_Drive/raw_data/test/stage_2_images/*.dcm')

len(test_files)

# Save the images in png form
for file in test_files:
  save_dcm_png(file, '/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_3test_imgs')

test_imgs=[]
test_imgs_names=[]
for test_img in tqdm(glob("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_3test_imgs"+"/*.png")):
    test_imgs_names.append(os.path.basename(test_img)[:-4])
    test_imgs.append(np.array(Image.open(test_img)))

test_imgs=np.array(test_imgs)
test_imgs_names=np.array(test_imgs_names)

print(test_imgs.shape)
print(test_imgs_names.shape)

# create a new directory to save the files in npy form
test_path = ("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_4test_imgs")
os.makedirs(test_path, exist_ok=True)

np.save("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_4test_imgs/test_imgs.npy", test_imgs, allow_pickle=True)
np.save("/content/drive/Shareddrives/Comp 540/Test_shared_Drive/processed/new_4test_imgs/test_imgs_names.npy", test_imgs_names, allow_pickle=True)